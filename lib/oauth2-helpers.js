// Generated by CoffeeScript 1.9.3
var AuthorizationError, buildTokenParams, clientInfo, generateJWT, isExpired, isScopeAllowed, isScopeAuthorized, jwt, normalizeList, normalizeScope, userInfo, validateClient;

jwt = require('jws');

AuthorizationError = require('./errors/authorizationerror');

clientInfo = function(client) {
  if (!client) {
    return client;
  }
  return client.id + ',' + client.name;
};

userInfo = function(user) {
  if (!user) {
    return user;
  }
  return user.id + ',' + user.username + ',' + user.email;
};

isExpired = function(tokenOrCode) {
  var expirationTime, issuedTime, now;
  issuedTime = tokenOrCode.issuedAt && tokenOrCode.issuedAt.getTime() || -1;
  now = Date.now();
  expirationTime = tokenOrCode.expiredAt && tokenOrCode.expiredAt.getTime() || -1;
  if (expirationTime === -1 && issuedTime !== -1 && typeof tokenOrCode.expiresIn === 'number') {
    expirationTime = issuedTime + tokenOrCode.expiresIn * 1000;
  }
  return now > expirationTime;
};


/**
 * Normalize items to string[]
 * @param {String|String[]} items
 * @returns {String[]}
 */

normalizeList = function(items) {
  var list;
  if (!items) {
    return [];
  }
  list = void 0;
  if (Array.isArray(items)) {
    list = [].concat(items);
  } else if (typeof items === 'string') {
    list = items.split(/[\s,]+/g).filter(Boolean);
  } else {
    throw new Error('Invalid items: ' + items);
  }
  return list;
};


/**
 * Normalize scope to string[]
 * @param {String|String[]} scope
 * @returns {String[]}
 */

normalizeScope = function(scope) {
  return normalizeList(scope);
};


/**
 * Check if one of the scopes is in the allowedScopes array
 * @param {String[]} allowedScopes An array of required scopes
 * @param {String[]} scopes An array of granted scopes
 * @returns {boolean}
 */

isScopeAllowed = function(allowedScopes, tokenScopes) {
  var i, n;
  allowedScopes = normalizeScope(allowedScopes);
  tokenScopes = normalizeScope(tokenScopes);
  if (allowedScopes.length === 0) {
    return true;
  }
  i = 0;
  n = allowedScopes.length;
  while (i < n) {
    if (tokenScopes.indexOf(allowedScopes[i]) !== -1) {
      return true;
    }
    i++;
  }
  return false;
};


/**
 * Check if the requested scopes are covered by authorized scopes
 * @param {String|String[]) requestedScopes
 * @param {String|String[]) authorizedScopes
 * @returns {boolean}
 */

isScopeAuthorized = function(requestedScopes, authorizedScopes) {
  var i, n;
  requestedScopes = normalizeScope(requestedScopes);
  authorizedScopes = normalizeScope(authorizedScopes);
  if (requestedScopes.length === 0) {
    return true;
  }
  i = 0;
  n = requestedScopes.length;
  while (i < n) {
    if (authorizedScopes.indexOf(requestedScopes[i]) === -1) {
      return false;
    }
    i++;
  }
  return true;
};

validateClient = function(client, options, next) {
  var authorizedGrantTypes, authorizedScopes, authorizedTypes, err, i, matched, n, redirectURIs, requestedScopes;
  options = options || {};
  next = next || function(err) {
    return err;
  };
  err = void 0;
  if (options.redirectURI) {
    redirectURIs = client.callbackUrls || client.redirectUris || client.redirectURIs || [];
    if (redirectURIs.length > 0) {
      matched = false;
      i = 0;
      n = redirectURIs.length;
      while (i < n) {
        if (options.redirectURI.indexOf(redirectURIs[i]) === 0) {
          matched = true;
          break;
        }
        i++;
      }
      if (!matched) {
        err = new AuthorizationError('Unauthorized redirectURI: ' + options.redirectURI, 'access_denied');
        return next(err) || err;
      }
    }
  }
  if (options.scope) {
    authorizedScopes = normalizeList(client.scopes);
    requestedScopes = normalizeList(options.scope);
    if (authorizedScopes.length && !isScopeAuthorized(requestedScopes, authorizedScopes)) {
      err = new AuthorizationError('Unauthorized scope: ' + options.scope, 'access_denied');
      return next(err) || err;
    }
  }
  if (options.responseType) {
    authorizedTypes = normalizeList(client.responseTypes);
    if (authorizedTypes.length && authorizedTypes.indexOf(options.responseType) === -1) {
      err = new AuthorizationError('Unauthorized response type: ' + options.responseType, 'access_denied');
      return next(err) || err;
    }
  }
  if (options.grantType) {
    authorizedGrantTypes = normalizeList(client.grantTypes);
    if (authorizedGrantTypes.length && authorizedGrantTypes.indexOf(options.grantType) === -1) {
      err = new AuthorizationError('Unauthorized grant type: ' + options.grantType, 'access_denied');
      return next(err) || err;
    }
  }
  return null;
};

generateJWT = function(payload, secret, alg) {
  var body;
  body = {
    header: {
      alg: alg || 'HS256'
    },
    secret: secret,
    payload: payload
  };
  return jwt.sign(body);
};

buildTokenParams = function(accessToken, token) {
  var p, params, scope;
  params = {
    expires_in: accessToken.expiresIn
  };
  scope = accessToken.scopes && accessToken.scopes.join(' ');
  if (scope) {
    params.scope = scope;
  }
  if (accessToken.refreshToken) {
    params.refresh_token = accessToken.refreshToken;
  }
  if (typeof token === 'object') {
    for (p in token) {
      if (p !== 'id' && !params[p] && token[p]) {
        params[p] = token[p];
      }
    }
  }
  return params;
};

module.exports = {
  clientInfo: clientInfo,
  userInfo: userInfo,
  isExpired: isExpired,
  normalizeList: normalizeList,
  validateClient: validateClient,
  isScopeAllowed: isScopeAllowed,
  isScopeAuthorized: isScopeAuthorized,
  generateJWT: generateJWT,
  buildTokenParams: buildTokenParams
};
